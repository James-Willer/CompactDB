document.addEventListener("DOMContentLoaded",(async()=>{let e,n=null,t=!1,s=!1,a=[],r=0,o=null,i=new Set;const l=document.getElementById("results-container"),c=document.getElementById("search-input"),d=document.getElementById("search-button"),u=document.getElementById("clear-search-button"),m=document.getElementById("page-header");function f(){l&&(l.innerHTML='\n                <div class="initial-empty-state">\n                    <i class="fas fa-hand-sparkles"></i>\n                    <h3>Welcome to CompactDB!</h3>\n                    <p>Start by searching for a game in the search bar above to view its compression analysis.</p>\n                    <p>You can search by full or partial game names.</p>\n                </div>\n            ',m&&(m.innerHTML='\n                    <h2>Compression Analysis</h2>\n                    <p>View and analyze compression results from <a href="https://github.com/IridiumIO/CompactGUI" target="_blank" rel="noopener noreferrer">CompactGUI</a></p>\n                '))}function h(e){if(0===e)return"0 Bytes";const n=Math.floor(Math.log(e)/Math.log(1024));return parseFloat((e/Math.pow(1024,n)).toFixed(2))+" "+["Bytes","KB","MB","GB","TB"][n]}function p(e,n){if(0===e)return{value:(0).toFixed(1),color:"#6c757d"};const t=((e-n)/e*100).toFixed(1);let s="#4bb543";return t<20&&t>=0?s="#f9c74f":t<0&&(s="#ef476f"),{value:t,color:s}}function y(e){return e?e.toLowerCase().replace(/[^a-z0-9\s]/g,"").replace(/\s+/g," ").trim():""}function v(e,n){const t=y(e),s=t.split(" ").filter(Boolean);return n.every((e=>t.includes(e)||s.some((n=>n.includes(e)))))}function g(e,n){const t=function(e,n){if(!e||!n||0===n.length)return e;const t=n.map((e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"))).join("|"),s=new RegExp(`(${t})`,"gi");return e.replace(s,"<mark>$1</mark>")}(e.GameName||"Unknown Game",n);let s={savings:-1/0,BeforeBytes:0,AfterBytes:0};e.CompressionResults&&e.CompressionResults.length>0&&e.CompressionResults.forEach((e=>{const n=e.BeforeBytes>0?(e.BeforeBytes-e.AfterBytes)/e.BeforeBytes*100:-1/0;n>s.savings&&(s={...e,savings:n})}));const a=p(s.BeforeBytes,s.AfterBytes);let r=`\n            <div class="game-card">\n                <div class="game-header">\n                    <h3 class="game-name">${t}</h3>\n                </div>\n                <div class="compression-summary">\n                    <div class="summary-item">\n                        <span class="summary-label">Best Savings</span>\n                        <span class="summary-value" style="color: ${a.color};">${a.value}%</span>\n                    </div>\n                    <div class="summary-item">\n                        <span class="summary-label">Original Size</span>\n                        <span class="summary-value">${h(s.BeforeBytes)}</span>\n                    </div>\n                    <div class="summary-item">\n                        <span class="summary-label">Compressed</span>\n                        <span class="summary-value">${h(s.AfterBytes)}</span>\n                    </div>\n                </div>\n                <div class="compression-details">\n                    <h4>Compression Details</h4>\n                    <table class="results-table">\n                        <thead>\n                            <tr><th>Type</th><th>Before</th><th>After</th><th>Savings</th><th>Entries</th></tr>\n                        </thead>\n                        <tbody>`;(e.CompressionResults||[]).forEach((e=>{const n=p(e.BeforeBytes,e.AfterBytes);var t;r+=`\n                <tr>\n                    <td>${t=e.CompType,{0:"XPRESS4K",1:"XPRESS8K",2:"XPRESS16K",3:"LZX"}[t]||`Unknown type ${t}`}</td>\n                    <td>${h(e.BeforeBytes)}</td>\n                    <td>${h(e.AfterBytes)}</td>\n                    <td style="color: ${n.color}">${n.value}%</td>\n                    <td>${e.TotalResults||0}</td>\n                </tr>`})),r+="</tbody></table></div>";const o=e.PoorlyCompressedExtensions||{};return Object.keys(o).length>0&&(r+=`\n                <div class="extension-list">\n                    <h4>Inefficient File Types</h4>\n                    <div class="extension-grid">\n                        ${Object.entries(o).sort(((e,n)=>n[1]-e[1])).map((([e,n])=>`\n                                <div class="extension-item">\n                                    <span class="extension-name">${e}</span>\n                                    <span class="extension-count">${n} files</span>\n                                </div>`)).join("")}\n                    </div>\n                </div>`),r+="</div>",r}async function $(e,n,t){if(s)return;s=!0;const c=l.querySelector("#lazy-load-sentinel");c&&c.remove();let d=0;for(let e=0;e<1&&r<a.length;e++){const e=a[r];try{const s=await fetch(e);if(r++,!s.ok){console.warn(`Failed to fetch chunk ${e}: ${s.status} ${s.statusText}`);continue}const a=await s.json(),o=document.createDocumentFragment();for(const e of a)if(v(e.GameName||"",n)&&!i.has(e.GameName)){i.add(e.GameName);const n=g(e,t),s=document.createElement("div");s.innerHTML=n,s.firstElementChild&&(o.appendChild(s.firstElementChild),d++)}l.appendChild(o)}catch(n){console.error(`Error loading or processing chunk ${e}:`,n)}}if(0===d&&r<a.length)return s=!1,void await $(e,n,t);if(r<a.length){const a=document.createElement("div");a.id="lazy-load-sentinel",l.appendChild(a),o&&o.disconnect(),o=new IntersectionObserver((async a=>{a[0].isIntersecting&&!s&&await $(e,n,t)}),{threshold:.1}),o.observe(a)}else o&&(o.disconnect(),o=null);s=!1}async function B(c){t||(t=!0,e&&clearTimeout(e),o&&(o.disconnect(),o=null),a=[],r=0,i.clear(),s=!1,l.innerHTML=`\n            <div class="loading">\n                <div class="spinner"></div>\n                <p>Searching for "${c}"...</p>\n            </div>`,m&&(m.innerHTML=`\n                <h2>Search Results</h2>\n                <p>Displaying compression analysis for games matching "${c}".</p>\n            `),e=setTimeout((async()=>{try{if(!n)throw new Error("Game index not loaded. Cannot perform search.");const e=c.trim();if(!e)return f(),void(t=!1);const s=e.toLowerCase().split(/\s+/).filter(Boolean),o=s.map(y),d=new Set;for(const[e,t]of Object.entries(n))v(e,o)&&t.forEach((e=>{const n=e.replace(/\.json$/,"")+".json";d.add(`./data/chunks/${n}`)}));if(a=Array.from(d),0===a.length)return l.innerHTML=`\n                        <div class="no-results">\n                            <i class="fas fa-search"></i>\n                            <h3>No results found for "${e}"</h3>\n                            <p>Try different search terms or check your spelling.</p>\n                        </div>`,void(t=!1);const u=l.querySelector(".loading p");u&&(u.textContent=`Calculating total results for "${e}"...`);const m=await async function(e,n){const t=new Set,s=e.map((async e=>{try{const n=await fetch(e);return n.ok?await n.json():(console.warn(`Pre-count: Failed to fetch chunk ${e}: ${n.status}`),[])}catch(n){return console.error(`Pre-count: Error fetching chunk ${e}:`,n),[]}})),a=await Promise.allSettled(s);for(const e of a)if("fulfilled"===e.status&&Array.isArray(e.value)){const s=e.value;for(const e of s)v(e.GameName||"",n)&&t.add(e.GameName)}return t.size}(a,o);if(0===m)return l.innerHTML=`\n                        <div class="no-results">\n                            <i class="fas fa-search"></i>\n                            <h3>No results found for "${e}"</h3>\n                            <p>Try different search terms or check your spelling.</p>\n                        </div>`,void(t=!1);l.innerHTML="";const h=document.createElement("div");h.className="results-header",h.innerHTML=`<h3>${m} ${1===m?"Result":"Results"} for "${e}"</h3>`,l.appendChild(h),r=0,i.clear(),await $(e,o,s)}catch(e){console.error("Search failed:",e),l.innerHTML=`\n                    <div class="error">\n                        <i class="fas fa-exclamation-triangle"></i>\n                        <h3>Search Failed</h3>\n                        <p>An error occurred: ${e.message}. Please try again.</p>\n                    </div>`}finally{t=!1}}),500))}function E(){""!==c.value.trim()?u.classList.add("visible"):u.classList.remove("visible")}d.addEventListener("click",(()=>B(c.value))),c.addEventListener("keyup",(e=>{E(),"Enter"===e.key?B(c.value):"Escape"===e.key&&""!==c.value.trim()&&(c.value="",E(),f())})),u.addEventListener("click",(()=>{c.value="",E(),o&&(o.disconnect(),o=null),f()})),c.addEventListener("input",E),c&&c.focus(),async function(){try{const e=await fetch("./data/game_index.json");if(!e.ok)throw new Error(`Failed to load game_index.json: ${e.status} ${e.statusText}`);n=await e.json(),console.log("Game index loaded successfully."),f()}catch(e){console.error("Error loading game index:",e),l&&(l.innerHTML='\n                    <div class="error">\n                        <i class="fas fa-exclamation-triangle"></i>\n                        <h3>Failed to Load Game Data</h3>\n                        <p>The essential game index could not be loaded. Please try refreshing the page.</p>\n                    </div>')}}()}));
//# sourceMappingURL=script.min.js.map